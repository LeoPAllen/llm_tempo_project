{% extends "global/Page.html" %}
{% load otree static %}

{#--------------------------------------------------------------#}
{# 1) Ensure oTree’s live.js and js_vars are injected           #}
{% block js_vars %}
    {{ super() }}
{% endblock %}

{#--------------------------------------------------------------#}
{% block content %}
  <p><strong>Treatment:</strong> {{ treatment }}</p>

  {# Task‐specific prompt area; override in subtemplates if needed #}
  {% block task_prompt %}
    <textarea id="user-input"
              rows="3"
              cols="60"
              placeholder="Type your prompt here…"></textarea><br>
  {% endblock %}

  <button type="button" id="submit-btn">Submit</button>
  <button type="button" id="interrupt-btn" disabled>⎋ Stop</button>

  <div id="conversation" style="margin-top:20px; white-space:pre-wrap;"></div>

  <label for="io-history"><strong>Your interaction history:</strong></label><br>
  <textarea id="io-history"
            name="io_history"
            rows="5"
            cols="60"
            readonly>{% if player.field_maybe_none('io_history') %}{{ player.field_maybe_none('io_history') }}{% endif %}</textarea>

  <input type="hidden" name="interrupt_latency_submit" id="interrupt-latency-submit">
  <input type="hidden" name="interrupt_latency_stream"  id="interrupt-latency-stream">

  {{ next_button }}
{% endblock %}

{#--------------------------------------------------------------#}
{% block global_scripts %}
<script>
document.addEventListener("DOMContentLoaded", function () {
  console.log("StreamingTask JS loaded; treatment =", "{{ treatment }}");

  // Parse treatment into delays
  const treatment = "{{ treatment }}";
  let startDelay = 0, streamDelay = 0;
  switch (treatment) {
    case "fast_start_fast_stream":
      startDelay  = 100; streamDelay = 100; break;
    case "fast_start_slow_stream":
      startDelay  = 100; streamDelay = 500; break;
    case "slow_start_fast_stream":
      startDelay  = 2000; streamDelay = 100; break;
    case "slow_start_slow_stream":
      startDelay  = 2000; streamDelay = 500; break;
    default:
      console.warn("Unknown treatment:", treatment);
  }

  const submitBtn          = document.getElementById("submit-btn");
  const interruptBtn       = document.getElementById("interrupt-btn");
  const inputField         = document.getElementById("user-input");
  const conversationDiv    = document.getElementById("conversation");
  const historyField       = document.querySelector('[name="io_history"]');
  const nextBtn            = document.querySelector('button[type="submit"], input[type="submit"]');
  const latencySubmitField = document.getElementById("interrupt-latency-submit");
  const latencyStreamField = document.getElementById("interrupt-latency-stream");

  let history       = [];
  let isStreaming   = false;
  let isInterrupted = false;
  let submitTime    = null;
  let streamTime    = null;

  function disableNext(on) {
    if (!nextBtn) return;
    nextBtn.disabled = on;
    nextBtn.style.opacity = on ? 0.5 : 1;
  }

  submitBtn.onclick = () => {
    if (isStreaming) return;
    const msg = inputField.value.trim();
    if (!msg) return;

    historyField.value = "";
    latencySubmitField.value  = "";
    latencyStreamField.value  = "";
    isInterrupted = false;

    disableNext(true);
    submitTime = Date.now();
    console.log("liveSend →", msg);
    liveSend({ input: msg });
  };

  interruptBtn.onclick = () => {
    if (!isStreaming || isInterrupted) return;
    isInterrupted = true;
    interruptBtn.disabled = true;
    const now = Date.now();
    latencySubmitField.value = now - submitTime;
    if (streamTime) latencyStreamField.value = now - streamTime;
  };

  liveRecv = async (data) => {
    console.log("liveRecv ←", data);
    isStreaming = true;
    streamTime  = null;

    const { input: userIn, output: fullOut } = data;

    // Render the user’s input
    const uP = document.createElement("p");
    uP.innerHTML = `<strong>You:</strong> ${userIn}`;
    conversationDiv.appendChild(uP);

    // Prepare assistant line
    const aP = document.createElement("p");
    aP.innerHTML = `<strong>Assistant:</strong> `;
    conversationDiv.appendChild(aP);

    // Tokenize and stream
    const chunks = fullOut.split(/\s+/).map(w => w + " ");
    interruptBtn.disabled = false;
    await new Promise(r => setTimeout(r, startDelay));
    streamTime = Date.now();

    let observed = "";
    for (const chunk of chunks) {
      if (isInterrupted) break;
      observed += chunk;
      aP.innerHTML = `<strong>Assistant:</strong> ${observed}`;
      if (streamDelay) {
        await new Promise(r => setTimeout(r, streamDelay));
      }
    }

    isStreaming = false;
    interruptBtn.disabled = true;
    disableNext(false);

    history.push({ input: userIn, output: observed.trim() });
    historyField.value = JSON.stringify(history);
  };
});
</script>
{% endblock %}
